---
title: "Class 12: RNA Seq Analysis"
author: "Ashley Martinez (PID: A17891957)"
format: html
toc: true
---

## Background
Today we will analyza some RNASeq data from Himes et. al. on the effects of a common steroid ( dexamethasone) in airway smooth muscle cells (ASM cells). 

A starting point is the "counts" data and "medadata" that contain the count values for each gene in their different experiments (i.e. cell lines with or without the drug).

## Data Import

```{r}
# Complete the missing code
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <-  read.csv("airway_metadata.csv")
```

Let's have a peek at these columns.

>Q1. How many genes are in this dataset?

```{r}
nrow(counts)
```

```{r}
nrow(metadata)
```

```{r}
head(counts)
```

```{r}
head(metadata)
```

>Q2. How many ‘control’ cell lines do we have?

**Answer**: 4

```{r}
sum(metadata$dex == "control")
```

## Toy with differential gene expression

To start, we will calculate the mean counts for all genes in the "control" experiments.

1. Extract all "control" columns from the 'counts' object
2. Calculate the mean for all rows (i.e. genes) of these "control" columns
3-4. Do the same for "treated"
5. Compare these 'control.mean' and 'treated.mean' values.

```{r}
control.inds<-metadata$dex=="control"
control.counts<-counts[,control.inds]
dim(control.counts)
```

```{r}
control.means<-rowMeans(control.counts)
```

```{r}
treated.inds<-metadata$dex=="treated"
treated.counts<-counts[,treated.inds]
dim(treated.counts)
```

```{r}
treated.means<-rowMeans(treated.counts)
```

Store the two control.means and treated.means together for bookkeeping.

```{r}
meancounts<-data.frame(control.means,treated.means)
head(meancounts)
```


>Q3. How would you make the above code in either approach more robust? Is there a function that could help here?

**Answer**: rowMeans(counts[,metadata$dex=="treated"])

>Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

**Answer**: See treated.means above.

>Q5a. Create a scatter plot of control vs treated.

```{r}
plot(control.means,treated.means)
```

>Q5 (b).You could also use the ggplot2 package to make this figure producing the plot below. What geom_?() function would you use for this plot?

**Answer**: Point

>Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this?

Make this plot a log plot to make the points more apparent.

```{r}
plot(meancounts,log="xy")
```

We often talk about metrics like "log2 fold-change"

```{r}
# treated/control
log2(10/10)
```

The log2 can help show what changes are going up or down.

```{r}
log2(10/40)
```

Let's calculate the log2 fold change for our treated over control mean counts.

```{r}
meancounts$log2fc<-log2(meancounts$treated.means/
  meancounts$control.means)
head(meancounts)
```

A common "rule of thumb" is a log2 fold change cutoff of +2 and -2 to call genes "Up regulated" or "Down regulated".

```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```

>Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?

**Answer**: arr.ind is used equal to TRUE so results are given as a matrix and the which() function specifies columns 1:2 and identifies where the value is 0. Unique () makes sure no row is counted twice.

Now let's filter what genes are up or down regulated.

```{r}
up.ind <- mycounts$log2fc > 2
down.ind <- mycounts$log2fc < (-2)

sum(up.ind)
sum(down.ind)
```

>Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level? 

**Answer**: 250

>Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level? 

**Answer**: 367

>Q10. Do you trust these results? Why or why not?

**Answer**: Not necessarily because fold change can be large without being significant. DESeq2 will need to be used to determine significance.

```{r}
library(DESeq2)
citation("DESeq2")
dds <- DESeqDataSetFromMatrix(countData=counts, 
                              colData=metadata, 
                              design=~dex)
dds
```

## Principal Component Analysis (PCA)

Now we will use PCA to analyze how the data samples are related to one another

```{r}
vsd <- vst(dds, blind = FALSE)
plotPCA(vsd, intgroup = c("dex"))
```

```{r}
pcaData <- plotPCA(vsd, intgroup=c("dex"), returnData=TRUE)
head(pcaData)
```

```{r}
library(ggplot2)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData) +
  aes(x = PC1, y = PC2, color = dex) +
  geom_point(size =3) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  coord_fixed() +
  theme_bw()
```

## DESeq Analysis

Now we can run the DESeq analysis. We will need to reassign DESeq(dds) to dds.

```{r}
dds <- DESeq(dds)
```

```{r}
res <- results(dds)
res
```

Now lets make a summary of res with an adjusted cutoff.

```{r}
res05 <- results(dds, alpha=0.05)
summary(res05)
```

## Adding Annotation Data

We will now use AnnotationDbi to map between IDs.

```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")
```

```{r}
columns(org.Hs.eg.db)
```

```{r}
res$symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), 
                     keytype="ENSEMBL",        
                     column="SYMBOL",          
                     multiVals="first")
head(res)
```

>Q11. Run the mapIds() function two more times to add the Entrez ID and UniProt accession and GENENAME as new columns called res$entrez, res$uniprot and res$genename.

**Answer**: 

```{r}
res$entrez <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

res$uniprot <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="UNIPROT",
                     keytype="ENSEMBL",
                     multiVals="first")

res$genename <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="GENENAME",
                     keytype="ENSEMBL",
                     multiVals="first")

head(res)
```

##Add gene annotation

To help make sense of our results and communicate them to other people we need to add some more annotation to our main 'res' object.

We will use two bioconductor packages to first map IDs to different formats including the classic gene "symbol" gene name.

I will install these with the following commands:
'BiocManager::install("AnnotationDbi")'
'BiocManager::install("org.Hs.eg.db")'

```{r}
library(AnnotationDbi)
library(org.Hs.eg.db)
```

Let's see what is in 'org.Hs.eg.db' with the 'columns()' function:

```{r}
columns(org.Hs.eg.db)
```

We can translate or "map" IDs between any of these 26 databases using the 'mapIds()' function.

```{r}
res$symbol <- mapIds(keys = row.names(res), #our current IDs
              keytype = "ENSEMBL",    #the format of our IDs
              x=org.Hs.eg.db,        #where to get the mappings from
              column="SYMBOL")       #the format/DB to map to

head(res)
```

Add the mappings for "GENENAME" and "ENTREZID" and store as 'res$genename' and 'res$entrez'

```{r}
res$entrez <- mapIds(keys = row.names(res), #our current IDs
              keytype = "ENSEMBL",    #the format of our IDs
              x=org.Hs.eg.db,        #where to get the mappings from
              column="ENTREZID")       #the format/DB to map to

res$genename <- mapIds(keys = row.names(res), #our current IDs
              keytype = "ENSEMBL",    #the format of our IDs
              x=org.Hs.eg.db,        #where to get the mappings from
              column="GENENAME")       #the format/DB to map to
```

```{r}
head(res, 10)
```

##Pathway Analysis

There are lots of bioconductor packages to do this type of analysis. For now let's just try one called **gage** again we need to install this if we don't have it already.

```{r,message=FALSE}
library(gage)
library(gageData)
library(pathview)
```

To use **gage** I need two things 

-a named vector of fold-change values for our DEGs (our geneset of interest)
-a set of pathways or genesets to use for annotation

```{r}
x<-c("barry"=5,"lisa"=10)
x
```

```{r}
names(x)<-c("low","high")
x
```

```{r}
foldchanges <- res$log2FoldChange
names(foldchanges)<-res$symbol
head(foldchanges)
```

```{r}
foldchanges <- res$log2FoldChange
names(foldchanges) = res$entrez
head(foldchanges)
data("kegg.sets.hs")
keggres = gage(foldchanges, gsets=kegg.sets.hs)
```

In our results object we have:
```{r}
attributes(keggres)
```

```{r}
head(keggres$less,5)
```

Let's look at one of these pathways (hsa05310 Asthma) with our genes colored up so we can see the overlap.

```{r}
pathview(pathway.id="hsa05310",gene.data=foldchanges)
```

Add this pathway figure to our lab report

![](hsa05310.pathview.png)

##Save our main results

```{r}
write.csv(res,file="myresults_annotated.csv")
```




